using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Asp.Versioning;
using FocusDeck.Domain.Entities.Automations;
using FocusDeck.Persistence;
using FocusDeck.Server.Services;
using FocusDeck.Server.Services.Automations;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;

namespace FocusDeck.Server.Controllers.v1.Jarvis
{
    [ApiController]
    [ApiVersion("1.0")]
    [Route("v{version:apiVersion}/automations/proposals")]
    [Authorize]
    public class AutomationProposalsController : ControllerBase
    {
        private readonly AutomationDbContext _dbContext;
        private readonly ActionExecutor _actionExecutor;
        private readonly IYamlAutomationLoader _yamlLoader;

        public AutomationProposalsController(
            AutomationDbContext dbContext,
            ActionExecutor actionExecutor,
            IYamlAutomationLoader yamlLoader)
        {
            _dbContext = dbContext;
            _actionExecutor = actionExecutor;
            _yamlLoader = yamlLoader;
        }

        /// <summary>
        /// Retrieves a list of pending automation proposals generated by Jarvis.
        /// </summary>
        [HttpGet]
        public async Task<ActionResult<List<AutomationProposalDto>>> GetProposals(CancellationToken cancellationToken)
        {
            var proposals = await _dbContext.AutomationProposals
                .AsNoTracking()
                .Where(p => p.Status == ProposalStatus.Pending)
                .OrderByDescending(p => p.CreatedAt)
                .Select(p => new AutomationProposalDto(
                    p.Id,
                    p.Title,
                    p.Description,
                    p.YamlDefinition,
                    p.ConfidenceScore))
                .ToListAsync(cancellationToken);

            return Ok(proposals);
        }

        /// <summary>
        /// Accepts a proposal, converting it into an active automation.
        /// </summary>
        [HttpPost("{id}/accept")]
        public async Task<IActionResult> AcceptProposal(System.Guid id, CancellationToken cancellationToken)
        {
            var proposal = await _dbContext.AutomationProposals.FindAsync(new object[] { id }, cancellationToken);
            if (proposal == null)
            {
                return NotFound("Proposal not found");
            }

            if (proposal.Status != ProposalStatus.Pending)
            {
                return BadRequest($"Proposal is already {proposal.Status}");
            }

            // Create active Automation
            // NOTE: Parsing YAML to objects (Trigger/Actions) would ideally happen here or in the engine loading.
            // For now, we persist the YAML and let the Engine parse it on load/refresh.
            var automation = new FocusDeck.Domain.Entities.Automations.Automation
            {
                Id = System.Guid.NewGuid(),
                Name = proposal.Title,
                Description = proposal.Description,
                YamlDefinition = proposal.YamlDefinition,
                IsEnabled = true,
                CreatedAt = System.DateTime.UtcNow,
                UpdatedAt = System.DateTime.UtcNow,
                TenantId = proposal.TenantId,
                // Stub Trigger/Actions to satisfy non-null if EF requires it (though they are handled by EF Core usually if ignored or mapped)
                // Assuming Automation uses EF Core conversion for Trigger/Actions JSON columns or ignored?
                // Checking Automation entity again...
                // Trigger/Actions are properties. AutomationDbContext likely maps them to JSON strings?
                // If mapped, we need to populate them or they will be null.
                // Let's parse basic info or initialize empty defaults.
                Trigger = new FocusDeck.Domain.Entities.Automations.AutomationTrigger { Type = "yaml_managed", Configuration = "{}" },
                Actions = new System.Collections.Generic.List<FocusDeck.Domain.Entities.Automations.AutomationAction>()
            };

            _dbContext.Automations.Add(automation);

            // Update Proposal
            proposal.Status = ProposalStatus.Accepted;

            await _dbContext.SaveChangesAsync(cancellationToken);

            // TODO: Notify AutomationEngine to reload?
            // For MVP, Engine can reload periodically or we inject it and call Reload().
            // We'll implement reloading in the Engine step.

            return Ok(new { AutomationId = automation.Id });
        }

        /// <summary>
        /// Rejects (deletes) a pending proposal.
        /// </summary>
        [HttpDelete("{id}")]
        public async Task<IActionResult> RejectProposal(System.Guid id, CancellationToken cancellationToken)
        {
            var proposal = await _dbContext.AutomationProposals.FindAsync(new object[] { id }, cancellationToken);
            if (proposal == null)
            {
                return NotFound("Proposal not found");
            }

            _dbContext.AutomationProposals.Remove(proposal);
            await _dbContext.SaveChangesAsync(cancellationToken);

            return NoContent();
        }

        /// <summary>
        /// Executes the actions defined in a proposal immediately (One-time run).
        /// </summary>
        [HttpPost("{id}/execute")]
        public async Task<IActionResult> ExecuteProposal(System.Guid id, CancellationToken cancellationToken)
        {
            var proposal = await _dbContext.AutomationProposals.FindAsync(new object[] { id }, cancellationToken);
            if (proposal == null) return NotFound("Proposal not found");

            // Parse YAML to get actions
            try
            {
                var parsed = _yamlLoader.Parse(proposal.YamlDefinition);
                if (parsed.Actions == null || parsed.Actions.Count == 0)
                {
                     return BadRequest("No actions defined in proposal.");
                }

                var results = new List<object>();
                foreach (var actionDto in parsed.Actions)
                {
                    var action = new FocusDeck.Domain.Entities.Automations.AutomationAction
                    {
                        ActionType = actionDto.Type,
                        Settings = actionDto.Settings ?? new Dictionary<string, string>()
                    };

                    var result = await _actionExecutor.ExecuteActionAsync(action, _dbContext);
                    results.Add(new { type = action.ActionType, success = result.Success, message = result.Message });
                }

                return Ok(new { success = true, actionResults = results });
            }
            catch (System.Exception ex)
            {
                return BadRequest($"Failed to execute proposal: {ex.Message}");
            }
        }
    }

    public record AutomationProposalDto(
        System.Guid Id,
        string Title,
        string Description,
        string YamlDefinition,
        float ConfidenceScore
    );
}
